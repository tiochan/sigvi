<?php
/**
 * @author Sebastian Gomez (tiochan@gmail.com)
 * For: Politechnical University of Catalonia (UPC), Spain.
 *
 * @package sigvi
 * @subpackage sources
 *
 * Source definition class
 *
 */

/*
	This class must be extended by every kind of source.

	+-----------------------------------------------------+
	|	IMPORTANT:                                        |
	|                                                     |
	|	The extender class must be called "inst_source".  |
	+-----------------------------------------------------+

	Main SIGVI process will call for these functions, as a usual file reading:

	Example:

	{
		require_once MY_INC_DIR . "/classes/vulnerability.class.php";
		require_once SYSHOME . "/plugins/sources/parsers/your_src.php";


		$vuln=new vulnerability("your_source_id");

		$your_src= new inst_source();

		$your_src->src_open() or die("Some error...");
		$your_src->src_read();

		// Now the array $your_src->vuln contains all the vulnerabilities
		// downloaded from source.
		print_r($your_src->vuln);

	}


	Of course, you have to define each of these functions!

	require:

	- init.inc.php loaded
*/

	abstract class source {

		public $db;
		public $test_mode;
		public $entries_found; 		// count number of new CVE entries found today
		public $entries_inserted;
		public $id_source;

		/**
		 * Vulnerability array. Will contains all the vulnerabilities after
		 * calling the read function.
		 */
		public $vuln;

		/**
		 * source constructor
		 *
		 */
		public function source(&$db, $id_source, $params) {

			$this->db= $db;
			$this->test_mode=false;
			$this->id_source=$id_source;
			$this->entries_found=0;
			$this->entries_inserted=0;
			$this->vuln= array();
		}

		/**
		 * Makes all the work.
		 * Will parse the source and will dump all into the vulnerability
		 * array (as "vulnerability" objects).
		 *
		 */
		abstract public function src_read();
	}


	/**
	 * Executes the load of all the sources.
	 *
	 *
	 * @param array of vuln $global_vuln_array
	 * @param string $report, the process report
	 * @param string $all_output, all the process output
	 * @param integer $id_source, if != "", the will use the specific source, else will use all "enabled"
	 * @param boolean $test_mode, if true, then will not store the vulnerabilities found on the database
	 */
	function go(&$global_vuln_array, &$report, &$all_output, $parm_id_source="", $test_mode=false) {

		global $global_db;
		global $MESSAGES;

		$report="";
		$all_output="";

		$global_vuln_array= array();

		if($parm_id_source!="") {
			$query="select * from vulnerability_sources where id_source='$parm_id_source'";
		} else {
			$query="select * from vulnerability_sources";
		}

		$res=$global_db->dbms_query($query);

		if($global_db->dbms_check_result($res)) {

			require_once MY_INC_DIR . "/classes/vulnerability.class.php";

			while($row=$global_db->dbms_fetch_array($res)) {

				$error="";

				$id_source= $row["id_source"];
				$name= $row["name"];
				$description= $row["description"];
				$parser= $row["parser"];
				$parameters= $row["parameters"];
				$use_it= $row["use_it"];

				$current_output="<HLINE><FONT color='gray'>Downloading vulnerabilities from source:<LINE_BREAK>" .
					 " - id_source: $id_source<LINE_BREAK>" .
					 " - <BOLD>name: $name</BOLD><LINE_BREAK>" .
					 " - description: $description<LINE_BREAK>" .
					 " - parser: $parser<LINE_BREAK>" .
					 " - parameters: $parameters<LINE_BREAK>" .
					 " - use_it: $use_it</FONT><LINE_BREAK><LINE_BREAK>\n";

				if(!CLI_MODE) my_echo($current_output);

				$all_output.=$current_output;

				if( $test_mode or ($use_it=='1') or ($parm_id_source!="") ) {

					$total_found=0;
					$total_inserted=0;
					
					unset($source_parser_class_name);
					
					{
						require_once SYSHOME . "/plugins/sources/vulnerability_parsers/" . $parser;
						
						if(!isset($source_parser_class_name)) {
							$error="Error, variable source_parser_class_name not initialized on parser $parser";
						} else {

							$your_src= new $source_parser_class_name($global_db, $id_source, $parameters);
							$your_src->test_mode=$test_mode;
	
							if(!$your_src->src_read()) {
								$error.="<FONT color='red'>Error opening source <SUBR>'$name'</SUBR> with parser <SUBR>'$parser'</SUBR></FONT>\n";
							} else {
								$global_vuln_array= array_merge($global_vuln_array, $your_src->vuln);
								$total_found= $your_src->entries_found;
								$total_inserted= $your_src->entries_inserted;
	
								//if($total_inserted == 0) $total_inserted="none";
	
								$msg="<HLINE>" . sprintf($MESSAGES["CRON_VULN_LOAD_BODY"], $name, $total_found, $total_inserted);
								$msg.="<LINE_BREAK>";
								log_write("LOAD VULN",$msg,0);
	
								if(!CLI_MODE) my_echo($msg);
	
								$all_output.= "<PARAGRAPH>" . $msg . "</PARAGRAPH>";
								$report.= "<PARAGRAPH>" . $msg . "</PARAGRAPH>";
							}
						}
					}

					if($error!="") {
						log_write("LOAD VULN",$error,0);
						$all_output.= "<PARAGRAPH>" . $error . "</PARAGRAPH>";
						if(!CLI_MODE) my_echo($error . "<LINE_BREAK>");
					}

				} else {
					$current_error= "<FONT color='#AA6666'><BOLD><ITALIC>This source is not enabled, continuing with next...</ITALIC></BOLD></FONT><HLINE>";
					if(!CLI_MODE) my_echo($current_error);
					$all_output.= $current_error;
				}
			}
			$global_db->dbms_free_result($res);
		}
	}
?>
<?php
/**
 * @author Sebastian Gomez (tiochan@gmail.com)
 * For: Politechnical University of Catalonia (UPC), Spain.
 *
 * @package sigvi
 * @subpackage vulnerability_sources
 *
 * NVD version prior to 1.2 source plugin
 *
 */

/*
	This script is a modification of the original xml parser for NVD.NIST.GOV for the adaption to
	the SIGVI environment. At the end of the file is stored the original header message.
*/

	include_once INC_DIR . "/output.inc.php";
	require_once MY_INC_DIR . "/classes/vulnerability.class.php";
	require_once MY_INC_DIR . "/classes/vulnerability_sources.class.php";

	$source_parser_class_name="cve10";

	class cve10 extends source {

		// PUBLIC
		public $URL;

		// PRIVATE
		private $fp;
		private $all_data;
		private $CVE;
		private $debug;
		private $insert;
		private $vendor;
		private $product;
		private $desc_type;
		private $xml_parser;


		// Examples for URL: "http://nvd.nist.gov/download/nvdcve-2005.xml", "/tmp/nvdcve-2005.xml"
		public function cve10(&$db, $id_source, $param) {

			parent::source($db, $id_source, $param);

			$this->URL=$param;
			$this->global_report="";
		}

		public function src_read() {

			// code for this function is from http://us2.php.net/xml
			$this->xml_parser = xml_parser_create();
			// use case-folding so we are sure to find the tag in $map_array
			xml_parser_set_option($this->xml_parser, XML_OPTION_CASE_FOLDING, true);
			xml_set_object($this->xml_parser, $this);
			xml_set_element_handler($this->xml_parser, "startElement", "endElement");
			xml_set_character_data_handler($this->xml_parser, "characterData");
			if (!($this->fp = fopen($this->URL, "r"))) {
				return 0;
			}

			$this->entries_found=0;
			$this->entries_inserted=0;
			$this->parse_this();

			fclose($this->fp);

			return 1;
		}

		private function startElement($parser, $name, $attrs) {
			//
			// the switch statement should enumerate all of the possible name tags.
			// State is kept using global variables, so that nested tags can
			// access their context.
			//
			switch ($name) {
				case 'ENTRY':

					$this->entries_found++;
					$this->vuln[]= new vulnerability($this->db,$this->id_source);
					// $this->vuln[count($this->vuln) - 1]->reset();

					// Example: <entry type="CVE" name="CVE-2005-0001" seq="2005-0001" discovered="2005-01-12" published="2005-05-02" modified="2005-10-20" severity="High">
					// get name and publication date
					$this->CVE = $this->validate_CVE($attrs['NAME']);
					$published = $this->validate_date($attrs['PUBLISHED']);
					$modified = isset($attrs['MODIFIED']) ? $this->validate_Date($attrs['MODIFIED']) : $published;

					$this->vuln[count($this->vuln) - 1]->severity= isset($attrs['SEVERITY'])? $attrs['SEVERITY']: "unknown";
					$this->vuln[count($this->vuln) - 1]->vuln_id=$this->CVE;
					$this->vuln[count($this->vuln) - 1]->publish_date=$published;
					$this->vuln[count($this->vuln) - 1]->modify_date=$modified;

					// my_echo("NEW CVE: " . $attrs["NAME"] . "-> " . $this->vuln[count($this->vuln) - 1]->vuln_id . ", " . $this->vuln[count($this->vuln) - 1]->publish_date . ", " . $this->vuln[count($this->vuln) - 1]->severity . "<LINE_BREAK>");
					// other attributes, such as severity, are available
					// see http://nvd.nist.gov/download/nvdcve-xmldoc.cfm

					break;
				case 'DESCRIPT':
					// if there ever was more than one type of description
					// remember which source with a global
					// NVD or CVE
					$this->desc_type = $attrs['SOURCE'];
					// reset data accumulator
					$this->all_data = '';
					// need to wait for end tag to get contents
					break;
				case 'PROD':
					$this->vendor = $attrs['VENDOR'];
					$this->product = $attrs['NAME'];
					if ($this->CVE == '') {
						if(!defined("QUIET"))
							my_echo("error, no CVE number");
						die;
					}
					if ($this->vendor == "") {
						// this happens
						if(!defined("QUIET"))
							my_echo("NVD integrity alert: no vendor for product $this->product, CVE is $this->CVE<LINE_BREAK>");
					}
					if ($this->product == "") {
						if(!defined("QUIET"))
							my_echo("NVD integrity alert: no product, CVE is $this->CVE<LINE_BREAK>");
					}
					break;
				case 'LOSS_TYPES':
					break;
				case 'VULNS_TYPES':
					break;
				case 'REF':
					if($this->vuln[count($this->vuln) - 1]->links!="") {
						$this->vuln[count($this->vuln) - 1]->links.="\n";
					}

					$this->vuln[count($this->vuln) - 1]->links.= $attrs['SOURCE'] . " AT " . $attrs['URL'];
					$this->all_data = '';
					// need to wait for end tag to get contents
					break;
				case 'VERS':
					if($this->vuln[count($this->vuln) - 1]->vuln_software!="") {
						$this->vuln[count($this->vuln) - 1]->vuln_software.="\n";
					}
					$this->vuln[count($this->vuln) - 1]->vuln_software.="$this->vendor, $this->product, " . $attrs['NUM'] . "; ";
					break;
				case '':
					break;
			}
		}


		private function endElement($parser, $name) {

			switch ($name) {
				case 'ENTRY':

					// New entry found, store last... if exists
					if($this->entries_found > 0) {
						if(!$this->test_mode) {
							if($this->vuln[count($this->vuln) - 1]->store_it()) {
								//$this->vuln[count($this->vuln) - 1]->build_body(true);
								$this->entries_inserted++;
							}
						} else {
							$this->vuln[count($this->vuln) - 1]->show_contents();
						}
					}

					$this->CVE = '';
					break;
				case 'DESCRIPT':
					if ($this->CVE == '') {
						if(!defined("QUIET"))
							my_echo("error, no CVE number");
						die;
					}
					$this->vuln[count($this->vuln) - 1]->description=$this->all_data;

					// reset data accumulator
					$this->all_data = '';
					break;
				case 'REF':
					if($this->vuln[count($this->vuln) - 1]->links!="")
						$this->vuln[count($this->vuln) - 1]->links.="\n";

					$this->vuln[count($this->vuln) - 1]->links.= $this->all_data;

					// reset data accumulator
					$this->all_data = '';
					break;
				case 'AVAIL':
					$this->vuln[count($this->vuln) - 1]->lt_availability=1;
					break;
				case 'CONF':
					$this->vuln[count($this->vuln) - 1]->lt_confidentiality=1;
					break;
				case 'INT':
					$this->vuln[count($this->vuln) - 1]->lt_integrity=1;
					break;
				case 'SEC_PROT':
					$this->vuln[count($this->vuln) - 1]->lt_security_protection=1;
					break;
				case 'ACCESS':
					$this->vuln[count($this->vuln) - 1]->vt_access_validation_error=1;
					break;
				case 'INPUT':
					$this->vuln[count($this->vuln) - 1]->vt_input_validation_error=1;
					break;
				case 'DESIGN':
					$this->vuln[count($this->vuln) - 1]->vt_other_vulnerability_type=1;
					break;
				case 'EXCEPTION':
					$this->vuln[count($this->vuln) - 1]->vt_exceptional_condition_error=1;
					break;
				case 'ENV':
					$this->vuln[count($this->vuln) - 1]->vt_environment_error=1;
					break;
				case 'CONFIG':
					$this->vuln[count($this->vuln) - 1]->vt_configuration_error=1;
					break;
				case 'RACE':
					$this->vuln[count($this->vuln) - 1]->vt_race_condition=1;
					break;
				case 'OTHER':
					$this->vuln[count($this->vuln) - 1]->vt_other_vulnerability_type=1;
					break;
				case 'REMOTE':
					$this->vuln[count($this->vuln) - 1]->ar_launch_remotely=1;
					break;
				case 'LOCAL':
					$this->vuln[count($this->vuln) - 1]->ar_launch_locally=1;
					break;
				case 'USER_INIT':
					//$this->vuln[count($this->vuln) - 1]->ar_launch_user=1;
					break;
				case '':
				break;
			}
		}

		private function characterData($parser, $data) {
			// concatenate due to bug with & according to a user entry in PHP docs
			// entry by sam at cwa dot co dot nz, Sept 2000
			// This issue might have been fixed later.  The fix can't hurt though.
			$this->all_data .= $data;
		}

		private function parse_this() {
			$counter=0;

			while ($data = fread($this->fp, 4096)) {
				{
					if (!xml_parse($this->xml_parser, $data, feof($this->fp))) {
						die(sprintf("XML error: %s at line %d",
						xml_error_string(xml_get_error_code($this->xml_parser)),
						xml_get_current_line_number($this->xml_parser)));
					}
				}
				$counter++;

				// For test mode only do it for 15 iterations.
				if($this->test_mode and ($counter==15)){
					break;
				}
			}
			xml_parser_free($this->xml_parser);
		}

		private function validate_CVE($input) {
			// expecting something like CAN-2004-0002
			// NVD documentation suggests this reg exp,
			// (http://nvd.nist.gov/download/nvdcve-xmldoc.cfm)
			// (CAN|CVE)-/d/d/d/d-/d/d/d/d
			// which doesn't work.  See below
			if (preg_match('/(CAN|CVE)-\d\d\d\d-\d\d\d\d/', $input, $matches)) {
				return $matches[0];
			} else {
				// if there was an error (false) or if 0 matches
				die ("Invalid CVE number encountered: $input");
			}
		}

		private function validate_Date($input) {
			// expecting something like 2004-03-03
			if (preg_match('/\d\d\d\d-\d\d-\d\d/', $input, $matches)) {
				return $matches[0];
			} else {
				// if there was an error (false) or if 0 matches
				die ("Invalid date encountered: $input");
			}
		}

	}


/********************************************************************************************************
* ORIGINAL MESSAGE FROM nvd_xml_parser:


*  XML parser for the NIST's National Vulnerability Database (NVD)
*   Open Source license, NCSA/U. of Illinois
*   Version 1.01, September 2, 2005
*   Pascal Meunier
*   Purdue University CERIAS
*   Contact: pmeunier

*  Uses the basic XML parser included with PHP
*  that doesn't perform schema validation
*   see http://us2.php.net/xml
*
*  The NVD's XML schema doesn't have conflicting name tags
*  at various nesting levels, so its parsing is relatively
*  simple.  Therefore, a flat namespace (independent of nesting level)
*  works fine.  This simple approach doesn't work, for example, with Microsoft's
*  XML export of vulnerabilities.

*  Note that this parser does not have cases for all tags in the NVD schema.
*  Simply add "case" statements for the additional tags that matter to you.
*
*  The data from parsing needs further validation or escaping if it is
*  to be inserted into another database.

*  -Replace the first line with the path to your installation of PHP
*  for command line execution.  Delete the path to PHP on the first line for
*  execution with an Apache web server.
*  -Choose a source for the XML file (see below)

*ChangeLog:
* 1.0 first version August 29, 2005
* 1.01 September 2, 2005
-Changed the name nvdcve-1999-2002.xml to nvdcve-2002.xml to match nvd changes
-Removed comment "from Apache" regarding https locations, as they work from the command line too,
 depending on how PHP was installed
-Now uses command line argument if present as XML source
-Now captures the content of <REF> tags
********************************************************************************************************/

